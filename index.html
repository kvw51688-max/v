<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <title>DIY Poster Creator – Fixed (24×30 / 24×50 in)</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- html2canvas & jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <!-- Google Fonts (trimmed to common set for performance) -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Poppins:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root { --ab-h: 64px; } /* JS will update at runtime */

    body {
      padding-bottom: calc(var(--ab-h) + env(safe-area-inset-bottom, 0px));
    }
    @media (min-width:1024px){
      body { padding-bottom: 0; }
    }

    .draggable{
      position:absolute; cursor:move; user-select:none; touch-action:none;
      white-space:pre-wrap; line-height:1.15;
      transition: box-shadow .15s ease, outline-color .15s ease, outline-offset .15s ease;
    }
    .draggable.active{
      outline:2px dashed #6366f1;
      outline-offset:2px;
    }
    .draggable.editing{
      cursor:text;
      outline:2px solid #6366f1;
      outline-offset:2px;
      box-shadow: 0 0 0 4px rgba(99,102,241,.15);
    }

    #previewStage{
      width:100%; max-width:960px; margin:0 auto; aspect-ratio:4/5;
      position:relative; background:#fff; border:1px dashed #cbd5e1; overflow:hidden;
    }
    #previewBgWrap{ position:absolute; inset:0; overflow:hidden; background:#f3f4f6; }
    #previewBgImg{ width:100%; height:100%; object-fit:cover; display:block; }

    #printStage{ position:fixed; left:-99999px; top:-99999px; background:#fff; overflow:hidden; }
    .guide{ position:absolute; left:0; right:0; top:50%; height:1px; background:rgba(0,0,0,.08); }
    .guide.v{ top:0; bottom:0; left:50%; width:1px; height:auto; }

    /* Thumbs */
    .thumb-grid{ display:grid; grid-template-columns: repeat(4,minmax(0,1fr)); gap:8px; }
    @media (min-width:768px){ .thumb-grid{ grid-template-columns: repeat(5,minmax(0,1fr)); } }
    .thumb-btn{
      position:relative; border:2px solid transparent; border-radius:10px; overflow:hidden; background:#e5e7eb;
      aspect-ratio:3/2; display:block;
    }
    .thumb-btn.active{ outline:2px solid #6366f1; border-color:#6366f1; }
    .thumb-img{ width:100%; height:100%; object-fit:cover; display:block; }
    .thumb-skeleton{
      position:absolute; inset:0; background:linear-gradient(90deg,#e5e7eb,#f3f4f6,#e5e7eb);
      background-size:200% 100%; animation: shimmer 1.2s infinite linear;
    }
    @keyframes shimmer{ 0%{background-position:200% 0;} 100%{background-position:-200% 0;} }

    /* Floating toolbar & status */
    .gp5-inline-toolbar{
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 9999;
      display: flex;
      gap: 8px;
      background: rgba(248,250,252,0.95);
      border: 1px solid rgba(100,116,139,0.25);
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
      backdrop-filter: blur(6px);
    }
    .gp5-inline-toolbar button{
      font: 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(100,116,139,0.30);
      background: white;
      cursor: pointer;
    }
    .gp5-inline-toolbar button:hover{ background: #f1f5f9; }
    .gp5-editing-highlight{ outline: 1.5px dashed #94a3b8; outline-offset: 2px; }
    #statusMsg[role="status"]{
      position: fixed; left: 12px; bottom: 12px; z-index: 9998;
      background: rgba(17,24,39,0.8); color: white; padding: 6px 10px; border-radius: 10px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    /* Action bar */
    #actionBar{ transition: transform .22s ease; will-change: transform; }
    #actionBar.ab-hidden{ transform: translateY(110%); }
    @media (max-width:1023px){
      body.mobile-sticky-padding{ padding-bottom: 0 !important; }
      #actionBar.mobile-sticky{
        position: sticky !important;
        bottom: 0;
        left: 0; right: 0;
        transform: none !important;
      }
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Header -->
  <header class="border-b bg-white sticky top-0 z-30">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between gap-4">
      <h1 class="text-lg md:text-xl font-semibold">DIY Poster Creator</h1>
      <div class="flex items-center gap-2 text-sm">
        <span class="px-2 py-1 rounded bg-slate-100">24×30 / 24×50 in</span>
        <span class="hidden md:inline text-slate-500">Preview 1920px • Print 300/200 dpi</span>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto p-4 grid grid-cols-1 lg:grid-cols-12 gap-4">
    <!-- Preview -->
    <section class="lg:col-span-8">
      <div class="mb-3 text-xs md:text-sm p-2 rounded border bg-blue-50 text-blue-800" id="tipBar">
        Click a text to select; <b>double-click</b> (desktop) or <b>long-press 0.6s</b> (mobile) to edit inline.
        Press <kbd>Esc</kbd> or tap outside to finish. Export at <b>300 dpi</b> (auto-fall back to <b>200</b> / <b>150</b> dpi on mobile if too large).
      </div>

      <div id="previewStage" class="rounded-lg shadow-sm bg-white" tabindex="0" aria-label="Poster preview stage">
        <div id="previewBgWrap"><img id="previewBgImg" alt="background"></div>
        <div class="guide hidden" id="guideH"></div>
        <div class="guide v hidden" id="guideV"></div>

        <!-- Draggable texts (percent positioning) -->
        <div id="t1" class="draggable text-3xl font-bold" style="left:10%; top:10%;">MAIN TITLE</div>
        <div id="t2" class="draggable text-xl" style="left:10%; top:25%;">Subtitle goes here</div>
        <div id="t3" class="draggable text-base" style="left:10%; top:40%;">Description or notes</div>
      </div>

      <div class="mt-3 text-xs md:text-sm text-slate-600" id="specInfo"></div>
    </section>

    <!-- Controls -->
    <aside class="lg:col-span-4">
      <div class="bg-white rounded-xl shadow p-4 space-y-4">
        <!-- Size -->
        <div>
          <label class="block text-sm font-medium mb-1">Poster Size (inches)</label>
          <select id="sizeSelect" class="w-full border rounded px-3 py-2" aria-label="Choose poster size in inches">
            <option value="24x30">24 × 30 in (preview 1920×2400)</option>
            <option value="24x50">24 × 50 in (preview 1920×4000)</option>
          </select>
        </div>

        <!-- DPI + Guides -->
        <div class="grid grid-cols-2 gap-2">
          <div>
            <label class="block text-sm font-medium mb-1">Print DPI</label>
            <select id="dpiSelect" class="w-full border rounded px-3 py-2" aria-label="Choose print DPI">
              <option value="300" selected>300 dpi (print-ready)</option>
              <option value="200">200 dpi (lighter)</option>
              <option value="150">150 dpi (mobile safe)</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium mb-1">Guides</label>
            <select id="guideSelect" class="w-full border rounded px-3 py-2" aria-label="Toggle center guides">
              <option value="off" selected>Off</option>
              <option value="on">Show center guides</option>
            </select>
          </div>
        </div>

        <!-- Background picker -->
        <div class="space-y-2">
          <div class="flex items-center justify-between gap-2">
            <label class="text-sm font-medium">Backgrounds</label>
            <div class="flex items-center gap-2">
              <input type="file" id="bgUpload" accept="image/*" class="block w-[180px] text-xs" aria-label="Upload custom background image" />
              <button id="resetBg" class="text-xs px-2 py-1 rounded bg-slate-100 hover:bg-slate-200" aria-label="Reset to default background">Reset</button>
            </div>
          </div>

          <!-- Thumbs + pagination -->
          <div class="space-y-2">
            <div id="thumbGrid" class="thumb-grid rounded border bg-slate-50 p-2"></div>
            <div class="flex items-center justify-between">
              <div class="text-xs text-slate-500" id="pageInfo">Page 1 / 1</div>
              <div class="flex items-center gap-1">
                <button id="pageFirst" class="px-2 py-1 text-xs rounded bg-slate-100 hover:bg-slate-200" aria-label="Go to first page">« First</button>
                <button id="pagePrev"  class="px-2 py-1 text-xs rounded bg-slate-100 hover:bg-slate-200" aria-label="Go to previous page">‹ Prev</button>
                <button id="pageNext"  class="px-2 py-1 text-xs rounded bg-slate-100 hover:bg-slate-200" aria-label="Go to next page">Next ›</button>
                <button id="pageLast"  class="px-2 py-1 text-xs rounded bg-slate-100 hover:bg-slate-200" aria-label="Go to last page">Last »</button>
              </div>
            </div>
          </div>

          <p class="text-xs text-slate-500">
            Tip: Thumbnails are lazy-loaded. Print uses originals at 300/200/150 dpi. Local uploads are embedded and added to the library.
          </p>
        </div>

        <!-- Text editor -->
        <div class="space-y-3">
          <div class="flex items-center justify-between">
            <span class="text-sm font-medium">Edit Text</span>
            <div class="text-xs space-x-1">
              <button data-target="t1" class="pickTarget px-2 py-1 rounded bg-slate-100" aria-label="Edit text block 1">Text 1</button>
              <button data-target="t2" class="pickTarget px-2 py-1 rounded bg-slate-100" aria-label="Edit text block 2">Text 2</button>
              <button data-target="t3" class="pickTarget px-2 py-1 rounded bg-slate-100" aria-label="Edit text block 3">Text 3</button>
            </div>
          </div>

          <textarea id="textContent" rows="3" class="w-full border rounded px-3 py-2 text-sm" placeholder="Type here…" aria-label="Edit selected text"></textarea>

          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="block text-xs mb-1">Font size (preview px)</label>
              <input type="number" id="fontSize" class="w-full border rounded px-2 py-1 text-sm" value="36" min="8" max="300" aria-label="Font size in pixels for preview" />
            </div>
            <div>
              <label class="block text-xs mb-1">Color</label>
              <input type="color" id="fontColor" class="w-full h-[36px] border rounded" value="#111827" aria-label="Font color" />
            </div>
          </div>

          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="block text-xs mb-1">Font family</label>
              <select id="fontFamily" class="w-full border rounded px-2 py-1 text-sm" aria-label="Font family">
                <option value="'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif">Inter (Sans)</option>
                <option value="'Roboto', system-ui, -apple-system, Segoe UI, Arial, sans-serif">Roboto (Sans)</option>
                <option value="'Montserrat', system-ui, -apple-system, Segoe UI, Arial, sans-serif">Montserrat (Sans)</option>
                <option value="'Poppins', system-ui, -apple-system, Segoe UI, Arial, sans-serif">Poppins (Sans)</option>
              </select>
            </div>
            <div class="flex flex-wrap items-center gap-2 text-xs">
              <label class="inline-flex items-center gap-1 mt-6"><input type="checkbox" id="bold"> Bold</label>
              <label class="inline-flex items-center gap-1 mt-6"><input type="checkbox" id="italic"> Italic</label>
              <label class="inline-flex items-center gap-1 mt-6"><input type="checkbox" id="underline"> Underline</label>
              <select id="align" class="border rounded px-2 py-1 mt-5" aria-label="Text alignment">
                <option value="left">Left</option>
                <option value="center">Center</option>
                <option value="right">Right</option>
              </select>
            </div>
          </div>

          <div class="grid grid-cols-3 gap-2">
            <div>
              <label class="block text-xs mb-1">Shadow strength</label>
              <input type="range" id="shadowStrength" min="0" max="100" value="35" aria-label="Text shadow strength" />
            </div>
            <div>
              <label class="block text-xs mb-1">Shadow blur</label>
              <input type="range" id="shadowBlur" min="0" max="30" value="10" aria-label="Text shadow blur" />
            </div>
            <div>
              <label class="block text-xs mb-1">Shadow color</label>
              <input type="color" id="shadowColor" value="#000000" class="w-full h-[36px] border rounded" aria-label="Text shadow color" />
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <!-- Footer -->
  <footer class="fixed bottom-0 left-0 right-0 border-t bg-white/95 backdrop-blur z-40" id="actionBar">
    <div class="max-w-6xl mx-auto px-4 py-3 flex flex-col md:flex-row items-center justify-between gap-3">
      <div class="text-xs md:text-sm text-slate-600" id="statusMsg" role="status" aria-live="polite">Ready. Pick a size & background, position your texts, then export.</div>
      <div class="flex flex-wrap items-center gap-2">
        <button id="btnWebPng"  class="px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-sm" aria-label="Download web PNG at 1920 pixels">Download Web PNG (1920px)</button>
        <button id="btnPrintPng" class="px-3 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white text-sm" aria-label="Download print-ready PNG at selected DPI">Download Print PNG (DPI)</button>
        <button id="btnPrintPdf" class="px-3 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 text-white text-sm" aria-label="Download print-ready PDF with true inches">Download Print PDF (true inches)</button>
      </div>
    </div>
  </footer>

  <div id="printStage"></div>

  <script>
    // ---------- Global helpers ----------
    function status(msg){ document.getElementById('statusMsg').textContent = msg; }
    function rgbToHex(rgb){
      const m=rgb && rgb.match && rgb.match(/\\d+/g); if(!m) return '#000000';
      const [r,g,b]=m.map(Number);
      return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
    }
    function cssColorToHex(c){
      if(!c) return '#000000';
      if(c.startsWith('#')) return c;
      const div=document.createElement('div'); div.style.color=c;
      document.body.appendChild(div);
      const hex = rgbToHex(getComputedStyle(div).color);
      document.body.removeChild(div);
      return hex;
    }
    async function ensureFontsReady(){
      if (document.fonts && document.fonts.ready) {
        try { await Promise.race([document.fonts.ready, new Promise(r=>setTimeout(r, 2500))]); } catch(_){}
      }
    }
    window.fetchAsBlobUrl = async function(url){
      try{
        if(!url) return null;
        const res = await fetch(url, {mode:'cors'});
        if(!res.ok) return null;
        const blob = await res.blob();
        return URL.createObjectURL(blob);
      }catch{ return null; }
    };
    async function preloadImage(url){
      if(!url) return;
      await new Promise(r=>{
        const im = new Image();
        im.crossOrigin='anonymous';
        im.onload = r; im.onerror = r;
        im.src = url;
      });
    }
    function lockScroll(){ document.body.style.overflow='hidden'; document.getElementById('actionBar').setAttribute('aria-busy','true'); }
    function unlockScroll(){ document.body.style.overflow=''; document.getElementById('actionBar').removeAttribute('aria-busy'); }

    function isMobileDevice(){ return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent); }
    function isIOS(){ return /iP(hone|ad|od)/i.test(navigator.userAgent); }

    function shouldDownscale(wPx, hPx){
      const isiOS = isIOS();
      const MAX_SIDE   = 9500;
      const MAX_PIXELS = isiOS ? 50e6 : 60e6;
      return (wPx > MAX_SIDE || hPx > MAX_SIDE || (wPx*hPx) > MAX_PIXELS);
    }

    function safeSessionSet(key, value){
      try { sessionStorage.setItem(key, value); }
      catch(e){ console.warn('Session quota exceeded', e); status('Tip: storage is full; newest uploads may not persist.'); }
    }
  </script>

  <script>
    // ---------- Default backgrounds for each size ----------
    const DEFAULT_BG = {
      '24x30': {
        small: 'https://kvw51688-max.github.io/v/24-30-1.webp',
        large: 'https://kvw51688-max.github.io/v/24-30-1.png'
      },
      '24x50': {
        small: 'https://kvw51688-max.github.io/v/24-50-1.webp',
        large: 'https://kvw51688-max.github.io/v/24-50-1.png'
      }
    };

    // ---------- Library (ensure large uses real large images) ----------
    const ASSET_LIBRARY = [
      { id:'lib-2430-1', label:'24×30 – BG #1', size:'24x30',
        small:'https://kvw51688-max.github.io/v/24-30-1.webp',
        large:'https://kvw51688-max.github.io/v/24-30-1.png' },
      { id:'lib-2430-2', label:'24×30 – BG #2', size:'24x30',
        small:'https://kvw51688-max.github.io/v/assets/images-small/24-30-2.png',
        large:'https://kvw51688-max.github.io/v/assets/images/24-30-2.png' },
      { id:'lib-2450-1', label:'24×50 – BG #1', size:'24x50',
        small:'https://kvw51688-max.github.io/v/24-50-1.webp',
        large:'https://kvw51688-max.github.io/v/24-50-1.png' },
      { id:'lib-2450-2', label:'24×50 – BG #2', size:'24x50',
        small:'https://kvw51688-max.github.io/v/assets/images-small/24-50-2.png',
        large:'https://kvw51688-max.github.io/v/assets/images/24-50-2.png' }
    ];

    const PAGE_SIZE = 12;

    // ---------- State ----------
    const state = {
      size:'24x30',
      dpi:300,
      preview:{
        width:1920, height:2400,
        bgSmall: DEFAULT_BG['24x30'].small,
        bgLarge: DEFAULT_BG['24x30'].large,
        isLocal:false
      },
      inches:{w:24, h:30},
      activeTextId:'t1',
      activeThumbId:null,
      inlineEditing:null,
      picks: { '24x30': null, '24x50': null },
      pageIndex: { '24x30': 0, '24x50': 0 }
    };

    // ---------- Elements ----------
    const previewStage = document.getElementById('previewStage');
    const previewBgImg = document.getElementById('previewBgImg');
    const printStage   = document.getElementById('printStage');

    const t1=document.getElementById('t1');
    const t2=document.getElementById('t2');
    const t3=document.getElementById('t3');
    const texts={t1,t2,t3};

    const sizeSelect  =document.getElementById('sizeSelect');
    const dpiSelect   =document.getElementById('dpiSelect');
    const guideSelect =document.getElementById('guideSelect');
    const specInfo    =document.getElementById('specInfo');
    const statusMsg   =document.getElementById('statusMsg');

    const textContent =document.getElementById('textContent');
    const fontSize    =document.getElementById('fontSize');
    const fontColor   =document.getElementById('fontColor');
    const bold        =document.getElementById('bold');
    const italic      =document.getElementById('italic');
    const underline   =document.getElementById('underline');
    const align       =document.getElementById('align');
    const fontFamily  =document.getElementById('fontFamily');

    const shadowStrength=document.getElementById('shadowStrength');
    const shadowBlur    =document.getElementById('shadowBlur');
    const shadowColor   =document.getElementById('shadowColor');

    const guideH=document.getElementById('guideH');
    const guideV=document.getElementById('guideV');

    const btnWebPng =document.getElementById('btnWebPng');
    const btnPrintPng=document.getElementById('btnPrintPng');
    const btnPrintPdf=document.getElementById('btnPrintPdf');

    const resetBg=document.getElementById('resetBg');

    const bgUpload =document.getElementById('bgUpload');
    const thumbGrid=document.getElementById('thumbGrid');
    const pageInfo =document.getElementById('pageInfo');
    const pageFirst=document.getElementById('pageFirst');
    const pagePrev =document.getElementById('pagePrev');
    const pageNext =document.getElementById('pageNext');
    const pageLast =document.getElementById('pageLast');

    // ---------- Busy wrapper for buttons ----------
    async function withBusy(el, fn){
      const old = el.textContent;
      el.disabled = true;
      el.textContent = 'Working...';
      el.classList.add('opacity-70','cursor-wait');
      lockScroll();
      try { await fn(); }
      catch(e){ console.error(e); alert('Export failed. Try 200/150 DPI or a smaller image.'); }
      finally{
        el.disabled = false;
        el.textContent = old;
        el.classList.remove('opacity-70','cursor-wait');
        unlockScroll();
      }
    }

    // ---------- Active highlight ----------
    function setActiveText(id){
      state.activeTextId = id;
      for (const el of Object.values(texts)) el.classList.remove('active');
      texts[id]?.classList.add('active');
      loadTextEditorFrom(id);
    }

    // ---------- Click / Double-Click & Long-Press ----------
    function attachClickToEdit(el){
      el.addEventListener('click', (e)=>{
        if (state.inlineEditing && state.inlineEditing !== el.id) return;
        setActiveText(el.id);
        e.stopPropagation();
      });

      el.addEventListener('dblclick', (e)=>{
        if (isMobileDevice()) return;
        enterInlineEdit(el);
        e.preventDefault(); e.stopPropagation();
      });

      enableLongPressEdit(el);

      el.addEventListener('mousedown', (e)=>{
        if (el.classList.contains('editing')) e.stopPropagation();
      });

      el.addEventListener('blur', ()=>{
        if (el.classList.contains('editing')) exitInlineEdit(el);
      });

      el.addEventListener('keydown', (e)=>{
        if (!el.classList.contains('editing')) return;
        if (e.key === 'Escape'){ e.preventDefault(); exitInlineEdit(el, true); return; }
        queueMicrotask(()=>{
          if (state.activeTextId === el.id) textContent.value = el.innerText;
        });
      });

      // paste as plain text for better cross-browser consistency
      el.addEventListener('paste', (e)=>{
        if (!el.classList.contains('editing')) return;
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData('text');
        document.execCommand('insertText', false, text);
      });
    }

    function enableLongPressEdit(el){
      let timer=null;
      el.addEventListener('touchstart', ()=>{
        if (el.classList.contains('editing')) return;
        timer = setTimeout(()=> enterInlineEdit(el), 600);
      }, {passive:true});
      ['touchend','touchmove','touchcancel'].forEach(ev=>{
        el.addEventListener(ev, ()=> { if (timer) { clearTimeout(timer); timer=null; } }, {passive:true});
      });
    }

    function enterInlineEdit(el){
      if (state.inlineEditing && texts[state.inlineEditing]) exitInlineEdit(texts[state.inlineEditing]);
      setActiveText(el.id);
      state.inlineEditing = el.id;
      el.classList.add('editing');
      try{ el.setAttribute('contenteditable', 'plaintext-only'); }catch(_){ el.setAttribute('contenteditable', 'true'); }
      if(isMobileDevice()) lockScroll();
      el.focus(); placeCaretAtEnd(el);
      status('Inline editing… Press Esc or tap outside to finish.');
    }
    function exitInlineEdit(el, keepFocusOutside=false){
      el.removeAttribute('contenteditable');
      el.classList.remove('editing');
      state.inlineEditing = null;
      if (state.activeTextId === el.id) textContent.value = el.innerText;
      if (!keepFocusOutside) previewStage.focus?.();
      if(isMobileDevice()) unlockScroll();
      status('Editing finished.');
    }
    function placeCaretAtEnd(el){
      const range = document.createRange();
      const sel = window.getSelection();
      range.selectNodeContents(el);
      range.collapse(false);
      sel.removeAllRanges(); sel.addRange(range);
    }
    document.addEventListener('click', (e)=>{
      if (!state.inlineEditing) return;
      const editingEl = texts[state.inlineEditing];
      if (editingEl && !editingEl.contains(e.target)) exitInlineEdit(editingEl);
    });

    // ---------- Text target picker ----------
    for(const el of document.querySelectorAll('.pickTarget')){
      el.addEventListener('click',()=> setActiveText(el.dataset.target));
    }

    // ---------- Size / DPI ----------
    function setSize(v){
      // Remember current pick
      state.picks[state.size] = {
        id: state.activeThumbId,
        small: state.preview.bgSmall,
        large: state.preview.bgLarge,
        isLocal: state.preview.isLocal
      };
      state.size=v;

      if(v==='24x30'){ state.preview.height=2400; state.inches={w:24,h:30}; previewStage.style.aspectRatio='4 / 5'; }
      else           { state.preview.height=4000; state.inches={w:24,h:50}; previewStage.style.aspectRatio='24 / 50'; }

      // iOS + 24×50：强制 200 DPI（只保留一处）
      if(isIOS() && v==='24x50'){
        dpiSelect.value='200';
        setDpi(200);
        status('On iPhone: 200 DPI set to improve stability.');
      }

      const pick = state.picks[v];
      if (pick && pick.small && pick.large){
        state.preview.isLocal = !!pick.isLocal;
        state.preview.bgSmall = pick.small;
        state.preview.bgLarge = pick.large;
        state.activeThumbId   = pick.id || null;
      } else {
        state.preview.isLocal = false;
        state.preview.bgSmall = DEFAULT_BG[v].small;
        state.preview.bgLarge = DEFAULT_BG[v].large;
        state.activeThumbId   = null;
      }

      applyPreviewBg();
      updateSpecInfo();

      if(state.pageIndex[v] == null) state.pageIndex[v] = 0;
      buildThumbs();
      clampPositionsToStage();
    }

    function setDpi(v){
      state.dpi=parseInt(v,10);
      updateSpecInfo();
      warnIfLocalTooSmall();
    }

    // ---------- Spec / Preview ----------
    function updateSpecInfo(){
      const {w,h}=state.inches;
      const pw=state.preview.width, ph=state.preview.height;
      const printWpx=Math.round(w*state.dpi), printHpx=Math.round(h*state.dpi);
      specInfo.innerHTML = `<b>Spec:</b> Preview ${pw}×${ph} px • Print ${w}×${h} in @ ${state.dpi} dpi → <b>${printWpx}×${printHpx} px</b>`;
    }

    function applyPreviewBg(){
      const url=state.preview.bgSmall;
      if (!url) { previewBgImg.removeAttribute('src'); return; }
      previewBgImg.crossOrigin = 'anonymous';
      previewBgImg.src = url;
    }

    sizeSelect.addEventListener('change',e=>setSize(e.target.value));
    dpiSelect.addEventListener('change',e=>setDpi(e.target.value));
    guideSelect.addEventListener('change',e=>{
      const on=e.target.value==='on';
      document.getElementById('guideH').classList.toggle('hidden',!on);
      document.getElementById('guideV').classList.toggle('hidden',!on);
    });

    // ---------- Library helpers ----------
    function loadLocalThumbs(size){
      const key=`localThumbs_${size}`;
      try{ return JSON.parse(sessionStorage.getItem(key)||'[]'); }catch{ return []; }
    }
    function saveLocalThumb(size,item){
      const key=`localThumbs_${size}`;
      const arr=loadLocalThumbs(size);
      if(!arr.some(i=>i.small===item.small)){
        arr.unshift(item);
        safeSessionSet(key, JSON.stringify(arr.slice(0,30)));
      }
    }
    function getAllItemsForSize(size){
      const locals=loadLocalThumbs(size);
      const items=ASSET_LIBRARY.filter(i=>i.size===size);
      return [...locals, ...items];
    }

    // ---------- Lazy loader for images ----------
    let io = null;
    function ensureIO(){
      if(io) return io;
      io = new IntersectionObserver((entries)=>{
        entries.forEach(entry=>{
          if(entry.isIntersecting){
            const img = entry.target;
            const src = img.getAttribute('data-src');
            if(src){
              img.src = src;
              img.onload = ()=> img.parentElement?.querySelector('.thumb-skeleton')?.remove?.();
              img.onerror = ()=> img.parentElement?.querySelector('.thumb-skeleton')?.remove?.();
              img.removeAttribute('data-src');
            }
            io.unobserve(img);
          }
        });
      }, {root: null, rootMargin:'100px', threshold: 0.01});
      return io;
    }

    // ---------- Build thumbs with pagination ----------
    function buildThumbs(){
      thumbGrid.innerHTML='';
      const size = state.size;
      const all = getAllItemsForSize(size);
      const total = all.length || 1;
      const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
      const page = Math.min(Math.max(0, state.pageIndex[size] || 0), totalPages - 1);
      state.pageIndex[size] = page;

      const start = page * PAGE_SIZE;
      const end = Math.min(total, start + PAGE_SIZE);
      const pageItems = all.slice(start, end);

      // Render each thumb (lazy)
      const _io = ensureIO();

      pageItems.forEach(item=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'thumb-btn';
        btn.title = item.label || 'Background';
        btn.dataset.small = item.small;
        btn.dataset.large = item.large || item.small;
        btn.dataset.id = item.id || '';
        btn.setAttribute('aria-label', item.label || 'Background thumbnail');
        if(state.activeThumbId && state.activeThumbId===item.id){ btn.classList.add('active'); }

        const sk = document.createElement('div');
        sk.className = 'thumb-skeleton';
        btn.appendChild(sk);

        const img = document.createElement('img');
        img.className = 'thumb-img';
        img.setAttribute('loading','lazy');
        img.setAttribute('alt', item.label || 'background');
        img.setAttribute('data-src', item.small);
        btn.appendChild(img);

        _io.observe(img);

        btn.addEventListener('click',()=>{
          state.preview.isLocal = !!item.isLocal;
          state.preview.bgSmall = item.small;
          state.preview.bgLarge = item.large || item.small;
          state.activeThumbId   = item.id || null;

          state.picks[state.size] = {
            id: state.activeThumbId,
            small: state.preview.bgSmall,
            large: state.preview.bgLarge,
            isLocal: state.preview.isLocal
          };

          document.querySelectorAll('.thumb-btn').forEach(n=>n.classList.remove('active'));
          btn.classList.add('active');
          applyPreviewBg();
          warnIfLocalTooSmall(item.naturalW, item.naturalH);
          status(item.isLocal?'Local background selected.':'Background set from repository assets.');
        });

        thumbGrid.appendChild(btn);
      });

      // Page UI
      pageInfo.textContent = `Page ${page+1} / ${totalPages}`;
      pageFirst.disabled = (page === 0);
      pagePrev.disabled  = (page === 0);
      pageNext.disabled  = (page >= totalPages-1);
      pageLast.disabled  = (page >= totalPages-1);
    }

    // ---------- Pagination actions ----------
    pageFirst.addEventListener('click', ()=>{ state.pageIndex[state.size]=0; buildThumbs(); });
    pagePrev .addEventListener('click', ()=>{
      state.pageIndex[state.size]=Math.max(0,(state.pageIndex[state.size]||0)-1); buildThumbs();
    });
    pageNext .addEventListener('click', ()=>{
      const all = getAllItemsForSize(state.size);
      const totalPages = Math.max(1, Math.ceil(all.length / PAGE_SIZE));
      state.pageIndex[state.size]=Math.min(totalPages-1,(state.pageIndex[state.size]||0)+1); buildThumbs();
    });
    pageLast .addEventListener('click', ()=>{
      const all = getAllItemsForSize(state.size);
      const totalPages = Math.max(1, Math.ceil(all.length / PAGE_SIZE));
      state.pageIndex[state.size]=totalPages-1; buildThumbs();
    });

    // ---------- Local upload ----------
    bgUpload.addEventListener('change', async(e)=>{
      const file=e.target.files?.[0]; if(!file) return;
      const dataUrl=await readFileAsDataURL(file);

      const img=new Image();
      img.onload=async ()=>{
        const thumb = await makeThumbnail(dataUrl, 480, 0.85);
        const item={
          id:`local-${Date.now()}`, label:`${state.size} – Local upload`,
          size:state.size, small:thumb, large:dataUrl, isLocal:true,
          naturalW:img.naturalWidth, naturalH:img.naturalHeight
        };
        state.preview.isLocal=true;
        state.preview.bgSmall=item.small;
        state.preview.bgLarge=item.large;
        state.activeThumbId=item.id;

        state.picks[state.size] = {
          id: state.activeThumbId,
          small: state.preview.bgSmall,
          large: state.preview.bgLarge,
          isLocal: true
        };

        applyPreviewBg();
        saveLocalThumb(state.size,item);

        state.pageIndex[state.size] = 0;
        buildThumbs();
        warnIfLocalTooSmall(img.naturalWidth,img.naturalHeight);
        status('Local background uploaded and added to the library.');
        bgUpload.value='';
      };
      img.src=dataUrl;
    });

    async function readFileAsDataURL(file){
      return new Promise((resolve,reject)=>{
        const fr=new FileReader();
        fr.onload=()=>resolve(fr.result);
        fr.onerror=reject;
        fr.readAsDataURL(file);
      });
    }
    async function makeThumbnail(dataUrl, maxW=480, quality=0.85){
      return new Promise((resolve)=>{
        const img = new Image();
        img.onload = ()=>{
          const scale = Math.min(1, maxW / img.naturalWidth);
          const w = Math.round(img.naturalWidth * scale);
          const h = Math.round(img.naturalHeight * scale);
          const c = document.createElement('canvas');
          c.width = w; c.height = h;
          const ctx = c.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          resolve(c.toDataURL('image/jpeg', quality));
        };
        img.src = dataUrl;
      });
    }

    // ---------- Text editor <-> preview ----------
    function loadTextEditorFrom(id){
      const el=texts[id];
      if (!el) return;
      for (const n of Object.values(texts)) n.classList.remove('active');
      el.classList.add('active');

      textContent.value=el.innerText;
      const cs=getComputedStyle(el);
      fontSize.value=parseInt(cs.fontSize,10);
      fontColor.value=rgbToHex(cs.color);

      const fam=cs.fontFamily;
      const opts=Array.from(fontFamily.options);
      const found=opts.find(o=>fam.toLowerCase().includes(o.value.split(',')[0].replace(/['"]/g,'').toLowerCase()));
      if(found) fontFamily.value=found.value;

      bold.checked=cs.fontWeight==='700'||parseInt(cs.fontWeight,10)>=600;
      italic.checked=cs.fontStyle==='italic';
      underline.checked=(cs.textDecorationLine||'').includes('underline');
      align.value=cs.textAlign||'left';

      // Dataset shadow preferred
      const dsS    = parseInt(el.dataset.shadowS ?? '', 10);
      const dsBlur = parseFloat(el.dataset.shadowBlur ?? '');
      const dsCol  = el.dataset.shadowColor;

      if (!Number.isNaN(dsS))      shadowStrength.value = Math.max(0, Math.min(100, dsS));
      if (!Number.isNaN(dsBlur))   shadowBlur.value     = Math.max(0, dsBlur);
      if (dsCol)                   shadowColor.value    = cssColorToHex(dsCol);

      if (Number.isNaN(dsS) || Number.isNaN(dsBlur) || !dsCol){
        const shadow = cs.textShadow || '';
        const m = shadow.match(/(-?\\d+(?:\\.\\d*)?)px\\s+(-?\\d+(?:\\.\\d*)?)px\\s+(\\d+(?:\\.\\d*)?)px\\s+(rgba?\\([^\\)]+\\)|#[0-9a-fA-F]{3,8}|[a-zA-Z]+)/);
        if(m){
          const s = Math.min(100, Math.round(Math.hypot(parseFloat(m[1]), parseFloat(m[2]))));
          const b = parseFloat(m[3]);
          const c = cssColorToHex(m[4]);
          if (Number.isNaN(dsS))    shadowStrength.value = s;
          if (Number.isNaN(dsBlur)) shadowBlur.value     = b;
          if (!dsCol)               shadowColor.value    = c;
        }
      }
    }

    function applyEditorTo(id){
      const el=texts[id];
      if (!el) return;
      el.innerText=textContent.value;
      el.style.fontSize=`${parseInt(fontSize.value,10)}px`;
      el.style.color=fontColor.value;
      el.style.fontWeight=bold.checked?'700':'400';
      el.style.fontStyle=italic.checked?'italic':'normal';
      el.style.textDecoration=underline.checked?'underline':'none';
      el.style.textAlign=align.value;
      el.style.fontFamily=fontFamily.value;

      const s=parseInt(shadowStrength.value,10);
      const blur=parseInt(shadowBlur.value,10);
      const off=Math.round(s/10);
      el.style.textShadow = s===0 ? 'none' : `${off}px ${off}px ${blur}px ${shadowColor.value}`;
      // store shadow params for export
      el.dataset.shadowS = String(s);
      el.dataset.shadowBlur = String(blur);
      el.dataset.shadowColor = shadowColor.value;
    }

    textContent.addEventListener('input', ()=>applyEditorTo(state.activeTextId));
    fontSize.addEventListener('input', ()=>applyEditorTo(state.activeTextId));
    fontColor.addEventListener('input', ()=>applyEditorTo(state.activeTextId));
    bold.addEventListener('change', ()=>applyEditorTo(state.activeTextId));
    italic.addEventListener('change', ()=>applyEditorTo(state.activeTextId));
    underline.addEventListener('change', ()=>applyEditorTo(state.activeTextId));
    align.addEventListener('change', ()=>applyEditorTo(state.activeTextId));
    fontFamily.addEventListener('change', ()=>applyEditorTo(state.activeTextId));
    shadowStrength.addEventListener('input', ()=>applyEditorTo(state.activeTextId));
    shadowBlur.addEventListener('input', ()=>applyEditorTo(state.activeTextId));
    shadowColor.addEventListener('input', ()=>applyEditorTo(state.activeTextId));

    // ---------- Drag (percent positioning) ----------
    for(const el of Object.values(texts)) makeDraggable(el,previewStage);

    function makeDraggable(el,boundary){
      normalizePercentPosition(el, boundary);

      let isDown=false; let startX=0,startY=0;
      let startLeftPx=0, startTopPx=0;

      const down=e=>{
        if (el.classList.contains('editing')) return;
        isDown=true;
        const p=getPoint(e);
        startX=p.x; startY=p.y;

        const brect=boundary.getBoundingClientRect();
        const {leftPercent, topPercent} = getInlineLeftTop(el, brect);
        startLeftPx = leftPercent * brect.width / 100;
        startTopPx  = topPercent  * brect.height/ 100;

        e.preventDefault();
        setActiveText(el.id);
      };

      const move=e=>{
        if(!isDown) return;
        if (el.classList.contains('editing')) return;
        const p=getPoint(e);
        const dx=p.x-startX, dy=p.y-startY;
        const brect=boundary.getBoundingClientRect();
        const rect=el.getBoundingClientRect();

        let leftPx = startLeftPx + dx;
        let topPx  = startTopPx  + dy;

        leftPx=Math.max(0,Math.min(leftPx,brect.width -rect.width));
        topPx =Math.max(0,Math.min(topPx ,brect.height-rect.height));

        const leftPercent = (leftPx / brect.width) * 100;
        const topPercent  = (topPx  / brect.height)* 100;

        el.style.left = `${leftPercent}%`;
        el.style.top  = `${topPercent}%`;

        el.dataset.leftPercent = leftPercent.toFixed(6);
        el.dataset.topPercent  = topPercent.toFixed(6);
      };

      const up=()=>{ isDown=false; };

      el.addEventListener('mousedown',down);
      window.addEventListener('mousemove',move);
      window.addEventListener('mouseup',up);
      el.addEventListener('touchstart',down,{passive:false});
      window.addEventListener('touchmove',move,{passive:false});
      window.addEventListener('touchend',up);
    }

    function normalizePercentPosition(el, boundary){
      const brect=boundary.getBoundingClientRect();
      let lp = parsePercent(el.style.left);
      let tp = parsePercent(el.style.top);

      if(Number.isNaN(lp) || Number.isNaN(tp)){
        const rect=el.getBoundingClientRect();
        const leftPx = rect.left - brect.left;
        const topPx  = rect.top  - brect.top;
        lp = (leftPx / brect.width) * 100;
        tp = (topPx  / brect.height)* 100;
      }

      el.style.left = `${lp}%`;
      el.style.top  = `${tp}%`;
      el.dataset.leftPercent = lp.toFixed(6);
      el.dataset.topPercent  = tp.toFixed(6);
    }

    function parsePercent(v){
      if(!v) return NaN;
      if(String(v).trim().endsWith('%')) return parseFloat(v);
      return NaN;
    }

    function getInlineLeftTop(el, brect){
      let lp = parsePercent(el.style.left);
      let tp = parsePercent(el.style.top);
      if(Number.isNaN(lp) || Number.isNaN(tp)){
        const rect=el.getBoundingClientRect();
        const leftPx = rect.left - brect.left;
        const topPx  = rect.top  - brect.top;
        lp = (leftPx / brect.width) * 100;
        tp = (topPx  / brect.height)* 100;
      }
      return { leftPercent: lp, topPercent: tp };
    }

    function clampPositionsToStage(){
      const brect=previewStage.getBoundingClientRect();
      for(const el of Object.values(texts)){
        const rect=el.getBoundingClientRect();

        let lp = parsePercent(el.style.left);
        let tp = parsePercent(el.style.top);
        if(Number.isNaN(lp) || Number.isNaN(tp)){
          const {leftPercent, topPercent} = getInlineLeftTop(el, brect);
          lp = leftPercent; tp = topPercent;
        }

        const maxLeftP = Math.max(0, (brect.width  - rect.width ) / brect.width  * 100);
        const maxTopP  = Math.max(0, (brect.height - rect.height) / brect.height * 100);

        lp = Math.min(Math.max(lp, 0), maxLeftP);
        tp = Math.min(Math.max(tp, 0), maxTopP);

        el.style.left = `${lp}%`;
        el.style.top  = `${tp}%`;
        el.dataset.leftPercent = lp.toFixed(6);
        el.dataset.topPercent  = tp.toFixed(6);
      }
    }

    function getPoint(e){ if(e.touches&&e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY}; return {x:e.clientX,y:e.clientY};}

    // ---------- Export ----------
    btnWebPng.addEventListener('click', ()=> withBusy(btnWebPng, async ()=>{
      status('Generating web preview PNG…');
      await ensureFontsReady();
      await preloadImage(state.preview.bgLarge || state.preview.bgSmall);
      const dataUrl=await renderPreviewPNG();
      triggerDownload(dataUrl,`poster-web-${state.size}.png`);
      status('Done.');
    }));

    btnPrintPng.addEventListener('click', ()=> withBusy(btnPrintPng, async ()=>{
      status(`Rendering print PNG (${state.dpi} dpi)…`);
      await ensureFontsReady();
      await preloadImage(state.preview.bgLarge || state.preview.bgSmall);
      const dataUrl=await renderPrintPNG();
      triggerDownload(dataUrl,`poster-print-${state.size}-${state.dpi}dpi.png`);
      status('Done.');
    }));

    btnPrintPdf.addEventListener('click', ()=> withBusy(btnPrintPdf, async ()=>{
      status(`Rendering print PDF (${state.dpi} dpi, true inches)…`);
      await ensureFontsReady();
      await preloadImage(state.preview.bgLarge || state.preview.bgSmall);
      const canvas=await renderPrintCanvas();
      const { jsPDF }=window.jspdf;
      const wIn=state.inches.w, hIn=state.inches.h;
      const pdf=new jsPDF({orientation:wIn>hIn?'l':'p', unit:'in', format:[wIn,hIn]});
      const imgData=canvas.toDataURL('image/jpeg',1);
      pdf.addImage(imgData,'JPEG',0,0,wIn,hIn);
      pdf.save(`poster-print-${state.size}-${state.dpi}dpi.pdf`);
      status('Done.');
    }));

    // Preview export: ignore guides and borders
    async function renderPreviewPNG(){
      const node = document.getElementById('previewStage');
      // temporarily remove border to avoid 1px offsets in capture
      const oldBorder = node.style.border;
      node.style.border = 'none';
      try{
        const canvas=await html2canvas(node,{
          allowTaint:false,
          useCORS:true,
          backgroundColor:'#ffffff',
          scale:1,
          ignoreElements: el => el.classList && el.classList.contains('guide')
        });
        return canvas.toDataURL('image/png');
      } finally {
        node.style.border = oldBorder;
      }
    }

    async function renderPrintPNG(){
      const canvas=await renderPrintCanvas();
      return canvas.toDataURL('image/png');
    }

    async function renderPrintCanvas(){
      const {w,h}=state.inches; let dpi=state.dpi;
      // Mobile safety
      if (isMobileDevice()) dpi = Math.min(150, dpi);

      let W=Math.round(w*dpi), H=Math.round(h*dpi);
      if (shouldDownscale(W,H)) {
        // One more step down for stability
        dpi = Math.min(150, dpi);
        W = Math.round(w*dpi);
        H = Math.round(h*dpi);
        status(`Target too large → auto-downgraded to ${dpi} dpi (${W}×${H}px).`);
      }

      printStage.innerHTML=''; printStage.style.width=W+'px'; printStage.style.height=H+'px';

      const bgUrl=state.preview.bgLarge||state.preview.bgSmall;
      const wrap=document.createElement('div');
      wrap.style.cssText=`position:relative;width:${W}px;height:${H}px;overflow:visible;background:#ffffff;`;
      const img=document.createElement('img');
      img.style.cssText='position:absolute;inset:0;width:100%;height:100%;object-fit:cover;';
      img.crossOrigin='anonymous';

      // use blob url first to avoid tainting
      let useUrl = bgUrl;
      const blobUrl = await window.fetchAsBlobUrl(bgUrl);
      if (blobUrl) useUrl = blobUrl;
      img.src = useUrl || '';
      wrap.appendChild(img);

      const pr=previewStage.getBoundingClientRect();
      const sx=W/pr.width, sy=H/pr.height;
      const k=(sx+sy)/2;

      await new Promise((res)=>{ if (!useUrl) return res(); img.onload=res; img.onerror=res; });

      for(const id of ['t1','t2','t3']){
        const src=texts[id];
        const srec=src.getBoundingClientRect();
        const cs=getComputedStyle(src);

        const el=document.createElement('div');
        el.textContent=src.textContent;

        el.style.position='absolute';
        el.style.left=((srec.left-pr.left)*sx)+'px';
        el.style.top =((srec.top -pr.top )*sy)+'px';

        // width mapping for multiline alignment parity
        const widthPx = srec.width * sx;
        el.style.display='inline-block';
        el.style.maxWidth=Math.max(50, Math.round(widthPx))+'px';
        el.style.whiteSpace='pre-wrap';

        const fontPx=parseFloat(cs.fontSize)*k;
        el.style.fontSize=fontPx+'px';
        el.style.fontFamily=cs.fontFamily;
        el.style.color=cs.color;
        el.style.fontWeight=cs.fontWeight;
        el.style.fontStyle=cs.fontStyle;
        el.style.textDecoration=cs.textDecoration;
        el.style.textAlign=cs.textAlign;
        el.style.lineHeight=(cs.lineHeight==='normal'?'1.15':cs.lineHeight);

        if(cs.letterSpacing && cs.letterSpacing.endsWith('px')){
          el.style.letterSpacing=(parseFloat(cs.letterSpacing)*k)+'px';
        }

        // text shadow (soft scaling)
        let sds = parseInt(src.dataset.shadowS || '0', 10);
        let sblur = parseFloat(src.dataset.shadowBlur || '0');
        let scolor = src.dataset.shadowColor || '';
        if(!(sds>0) && cs.textShadow){
          const mm = (cs.textShadow||'').match(/(-?\\d+(?:\\.\\d*)?)px\\s+(-?\\d+(?:\\.\\d*)?)px\\s+(\\d+(?:\\.\\d*)?)px\\s+(rgba?\\([^\\)]+\\)|#[0-9a-fA-F]{3,8}|[a-zA-Z]+)/);
          if(mm){
            const ox = parseFloat(mm[1]);
            const oy = parseFloat(mm[2]);
            sds = Math.round(Math.hypot(ox, oy));
            sblur = parseFloat(mm[3]);
            scolor = mm[4];
          }
        }
        if(sds>0){
          const off = Math.max(1, Math.round((sds/10) * (k/2)));
          const bl  = Math.max(0.5, sblur * Math.sqrt(k));
          el.style.textShadow = `${off}px ${off}px ${bl}px ${scolor || '#000'}`;
        } else {
          el.style.textShadow = 'none';
        }

        wrap.appendChild(el);
      }

      printStage.appendChild(wrap);

      await (document.fonts && document.fonts.ready);
      const canvas=await html2canvas(wrap,{
        allowTaint:false,useCORS:true,backgroundColor:'#ffffff',scale:1,windowWidth:W,windowHeight:H,letterRendering:true
      });
      return canvas;
    }

    function triggerDownload(dataUrl,filename){
      const a=document.createElement('a'); a.href=dataUrl; a.download=filename;
      document.body.appendChild(a); a.click(); a.remove();
    }

    function warnIfLocalTooSmall(nw,nh){
      if(state.preview.isLocal && (!nw||!nh)){
        const img=new Image();
        img.onload=()=>warnIfLocalTooSmall(img.naturalWidth,img.naturalHeight);
        img.src=state.preview.bgLarge||state.preview.bgSmall;
        return;
      }
      if(!nw||!nh) return;
      const needW=state.inches.w*state.dpi, needH=state.inches.h*state.dpi;
      if(nw<needW*0.98 || nh<needH*0.98){
        status(`Warning: local background may be too small for ${state.inches.w}×${state.inches.h} in @ ${state.dpi} dpi (need ~${needW}×${needH}px, got ${nw}×${nh}px). It will be upscaled.`);
      }
    }

    // ---------- First render ----------
    t1.style.fontFamily="'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    t2.style.fontFamily="'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    t3.style.fontFamily="'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";

    normalizePercentPosition(t1, previewStage);
    normalizePercentPosition(t2, previewStage);
    normalizePercentPosition(t3, previewStage);

    attachClickToEdit(t1);
    attachClickToEdit(t2);
    attachClickToEdit(t3);

    setSize('24x30');
    setDpi(dpiSelect.value);
    applyPreviewBg();
    buildThumbs();
    setActiveText(state.activeTextId);
    status('Ready. Choose a background from the library or upload locally.');
    if(isMobileDevice()){
      status('On mobile: long-press text to edit; exporting 300 dpi can be heavy — 200/150 dpi is recommended.');
    }

    // Reset 背景
    resetBg.addEventListener('click', ()=>{
      const v = state.size;
      state.preview.isLocal=false;
      state.preview.bgSmall=DEFAULT_BG[v].small;
      state.preview.bgLarge=DEFAULT_BG[v].large;
      state.activeThumbId=null;
      applyPreviewBg();
      buildThumbs();
      status('Background reset to default.');
    });

    // ActionBar sizing/hide on scroll
    (function(){
      const actionBar = document.getElementById('actionBar');

      function setActionBarHeightVar(){
        const h = (actionBar && actionBar.offsetHeight) ? actionBar.offsetHeight : 64;
        document.documentElement.style.setProperty('--ab-h', h + 'px');
      }

      window.addEventListener('load', setActionBarHeightVar, {once:true});
      window.addEventListener('resize', setActionBarHeightVar);
      window.addEventListener('orientationchange', setActionBarHeightVar);

      let lastY = window.scrollY || 0;
      window.addEventListener('scroll', () => {
        const y = window.scrollY || 0;
        if (!actionBar) return;
        if (y > lastY + 8)        actionBar.classList.add('ab-hidden');
        else if (y < lastY - 8)   actionBar.classList.remove('ab-hidden');
        lastY = y;
      }, {passive:true});

      const _enterInlineEdit = window.enterInlineEdit;
      const _exitInlineEdit  = window.exitInlineEdit;

      window.enterInlineEdit = function(el){
        if (actionBar) actionBar.classList.add('ab-hidden');
        return _enterInlineEdit ? _enterInlineEdit(el) : undefined;
      };
      window.exitInlineEdit = function(el, keepFocusOutside){
        if (actionBar) actionBar.classList.remove('ab-hidden');
        return _exitInlineEdit ? _exitInlineEdit(el, keepFocusOutside) : undefined;
      };

      document.addEventListener('click', () => {
        if (actionBar) actionBar.classList.remove('ab-hidden');
      }, {passive:true});
    })();

    (function(){
      const isMobile = () => window.matchMedia('(max-width:1023px)').matches;
      const bar = document.getElementById('actionBar');
      function applyMode(){
        if(!bar) return;
        if(isMobile()){
          bar.classList.add('mobile-sticky');
          document.body.classList.add('mobile-sticky-padding');
          bar.classList.remove('ab-hidden');
        }else{
          bar.classList.remove('mobile-sticky');
          document.body.classList.remove('mobile-sticky-padding');
        }
      }
      window.addEventListener('load', applyMode, {once:true});
      window.addEventListener('resize', applyMode);
      window.addEventListener('orientationchange', applyMode);
    })();

    // Keep texts clamped after viewport changes
    window.addEventListener('resize', clampPositionsToStage);
    window.addEventListener('orientationchange', clampPositionsToStage);
  </script>
</body>
</html>
